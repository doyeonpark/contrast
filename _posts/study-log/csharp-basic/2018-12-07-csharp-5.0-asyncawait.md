---
title:  "c# 기본서 - c# 5.0: async, await"
date:   2018-12-07 12:06:00
tags: [c#, c#5.0, async, await, Task, Task<TResult>, 호출자정보]
categories: study-log
---

### 호출자 정보
- c/c++에서 갖고오는 `__LINE__`, `__FILE__`와 같은 매크로 상수를 불러올 수 있게됐다.
- c#에서는 함수 파라미터에 attribute 형식으로 입력하면 된다.
    
    {% highlight c# %}
    static void LogMessage([CallerMemberName] string memberName = "", [CallerFilePath] string filePath = "", [CallerLineNumber] int lineNumber = 0)
    {
        //코드
    }
    {% endhighlight %}

    | 특성 | 설명 |
    |--------------|---------------|
    | CallerMemberName | 호출자 정보가 명시된 메서드를 호출한 측의 메서드 이름  |
    | CallerFilePath | 호출자 정보가 명시된 메서드를 호출한 측의 소스파일 경로  |
    | CallerLineNumber | 호출자 정보가 명시된 메서드를 호출한 측의 소스코드 라인 번호  |
    | where T: struct | 값 형식만 |


### async, await
- 비동기 호출을 동기호출처럼 사용할 수 있는 예약어
- FileRead()같은 함수는 비동기 함수가 별개로 있지만, 비동기로 호출할경우 콜백 함수를 쓰는등 복잡해지는 문제가 있었다.
- 사용 방법은 함수 앞에 await를 붙이고, 그 아래에 있는 코드를 콜백함수처럼 동기적으로 작성하면 된다.
- async는 await이라는 단어를 예약어로 인식하게 하도록 메소드 앞에 붙이는 예약어이다.
    - 하위호환을 위해 추가된 개념이다.


### 비동기 반환 타입: Task, Task<TResult>
- 비동기 메서드는 반환값이 있는 경우 Task<TResult>, 없는경우 Task 반환한다.
    - await예약어를 사용하지 않고 async 예약어를 사용할 경우 void 리턴도 가능한데, 이때 예외가 발생하면 처리되지 않은 채로 프로세스가 비정상적으로 종료되므로 권장되지 않는다.
    - 그럼에도 불구하고 async void가 있는 경우는 EventHandler 타입때문이다. 아래를 제시한 타입외에는 사용하지 말자.
    {% highlight c# %}
    public delegate void EventHandler(object sender, EventArgs e);
    {% endhighlight %}
- Task만 ThreadPool.QueueUserWorkItem대용으로 사용할수도 있다.
    {% highlight c# %}
    //동일한 코드이다
    ThreadPool.QueueWorkItem(
        (obj) =>
        {
            //코드
        }
    , null)

    Task task1 = new Task(
        () =>
        {
            //코드
        }
    , null)

    Task task2 = new Task(
        () =>
        {
            //코드
        }
    , null)

    task1.Start();
    task1.Wait();
    //차이점이라면 Task가 좀 더 세밀하게 제어할 수 있다. ThreadPool은 EventWaitHandle 타입을 통해 제어해야하는데, Wait();호출을 통해 작업완료까지 스레드 대기를 할 수있다.
    
    //Task.WaitAll(task1, task2)
    //두개의 스레드를 동시에 실행하고 대기할 수 있다.

    //await Task.WaitAll(task1, task2)
    //두개의 스레드를 동시에 실행하고 대기하지 않고 다음작업을 진행한다.
    {% endhighlight %}
- Task.Factory.StartNew(Action<T> func)이라는 정적 속성을 통해 Start()호출 없이 바로 시작할수도 있다.
- Task<TResult>를 사용해 반환값을 처리할수도 있다.
    {% highlight c# %}
    Task<int> task1 = new Task<int>(
        () =>
        {
            Random rand = new Random((int))
        }
    , null)
    task1.Start();
    task1.Wait();
    Console.WriteLine(task1.Result);
    {% endhighlight %}
- 비동기를 지원하지 않는 동기메서드를 비동기메서드처럼 구현할수도 있다.
    {% highlight c# %}
    static Task<string> ReadAllTextAsync(string filePath)
    {
        return TaskFactory.StartNew(() => 
        {
            File.ReadAllText(filePath);
        })
    }
    private static async Task AwaitFileRead(string filePath)
    {
        string fileText = await ReadAllTextAsync(filePath);
        // Task 반환타입을 갖지만 Async예약어가 있으므로 return 문이 필요없다.
    }
    {% endhighlight %}

