---
title:  "c# 기본서 - c# 6.0: 간편표기법"
date:   2018-12-07 12:06:00
tags: [c#, c#6.0, lambda, using, ?, null, dictionary, when, task]
categories: study-log
---

### 6.0 주요변화
- 간편 표기법정도의 변화가 있었다.
- 때문에 빌드할때는 c# 6.0이 필요하지만 빌드 결과를 실행하기위해선 .NET framework 2.0(c# 2.0)만 있으면 된다.


### 초기화 구문 추가
- 멤버 초기값을 부여하기 위해 생성자를 추가할 필요 없이, 부호입력만으로 초기값 입력을 할 수 있다.
    {% highlight c# %}
    public string Name { get; set; } = "Jane";
    //여기서 set;을 없애면 읽기전용으로 만들 수 있다.
    //즉, set;을 없애고 빌드하면 내부적으로 readonly 예약어를 추가한다.
    {% endhighlight %}


### 람다식을 이용한 메서드, 속성 정의
- 메서드 코드가 한줄이면 람다로 간편하게 정의가능하다.
    {% highlight c# %}
    public void PrintIt() => Console.WriteLine("프린트");
    {% endhighlight %}
- 속성 정의도 가능한데, 이 경우 get만 가능하다.
    {% highlight c# %}
    public double x;
    public double y;
    public double Angle => Math.Atan2(y, x);
    {% endhighlight %}
- 인덱서도 가능한데, 인덱서의 경우 7.0부터 set이 가능하다.

### using static 타입 생략
- 상단에 using static 전체 타입을 선언해주면 정적멤버를 타입명 없이 바로 호출할 수 있다.
- enum멤버나 const 속성을 갖는 클래스도 마찬가로 적용 가능하다.
    {% highlight c# %}
    using static MyDay;
    using static BitMode;

    public enum MyDay
    {
        Saturday, Sunday
    }

    public class BitMode
    {
        public const int ON = 1;
        public const int OFF = 2;
    }
    {% endhighlight %}
- 단, c# 3.0에 도입된 확장메서드는 using static 적용을 받지 않는다. 동일 메서드명간의 충돌이 있을 수 있기 때문이다.

### null 조건 연산자: ?
- 참조형 변수의 멤버접근이나 배열 인덱스접근을 할때 null check대신 간편하게 쓸 수 있다. 단독으로 쓸 수 없다.
    {% highlight c# %}
    int count = list?.Count ?? 0;

    //위 코드는 아래와 동일하다.
    if(list != null) {
        if(list.Count == null)
            count = 0;
        else
            count = list.Count;
    }
    {% endhighlight %}
- 하나의 참조변수에 대해 다중으로 사용할 경우 효율성이 떨어지므로 주의해서 쓸 것.

### 문자열 내에 식(expression) 포함
- string.Format의 활용도때문에 더 간편하고 쉽게 $""표기법이 추가되었다.


### nameof 추가
- 사용된 식별자(메서드, 속성 등)의 이름을 그대로 출력할때 사용한다.
- 단, 식별자의 마지막 이름만 반환되므로 주의.
    {% highlight c# %}
    string txt = nameof(System.Console);
    //txt == "Console"
    {% endhighlight %}
- 리플렉션을 통해서도 가능하지만(712p 참조), 리플렉션은 코드 실행되어야 이름이 구해지는 반면 nameof는 컴파일시에 치환되므로 실행시점에는 부하가 없다.

### Dictionary 타입의 초기화
- Dictionary의 간편한 초기화 방식을 지원한다.
    {% highlight c# %}
    //기존에 지원하던 초기화 방식
    var people = new Dictionary<string, int>
    {
        { "Anders", 7 },
        { "Sam", 10 },
        { "Sam", 7 } //에러발생!
        //위 방식은 컴파일 후 Add()메서드를 호출하는 코드로 변경되므로 키값 중복 에러가 발생한다.
    }

    //반면에 인덱서를 통한 접근방식은
    var people = new Dictionary<string, int>
    {
        ["Anders"] = 7,
        ["Sam"] = 10,
        ["Sam"] = 7 //기존 키값에 덮어쓰기도 가능하다
    }
    {% endhighlight %}

### 예외필터
- catch 옆에 when 조건식을 통해 해당 조건에 맞는 예외가 발생하면 예외처리기가 선택된다.
- 특이한 점은 예외 필터 조건식이 실행되는 시점은 예외 핸들러가 실행되는 시점이 아니므로 호출스택(call stack)이 그대로 보존된다.
    - 조건식에 특정 작업을 수행하고 무조건 false를 리턴하게 하면 예외 처리 구조에 영향을 주지 않고 부가적인 작업을 할 수 있다. (로그 무조건 남기게 하는등)
    - exception 전부를 받는 catch 문에 구현하는 수가 있지만, when을 통한 구문은 Intermediate Language수준에서 지원하므로 예외필터의 IL코드로 직접 변경된다는 차이가 있다.
- 같은 예외를 여러번 호출할수도 있지만 동일한 예외에서 실제로 실행되는것은 한개이다.

### try/catch에서 await 사용 가능

### #pragma의 "CS"접두사 지원
- 특정 경고를 끄려면 기존에는 경고코드의 숫자만 입력해야 했지만 이제는 전체를 사용해도 된다.
    {% highlight c# %}
    //코드 상단부에 선언
    #pragma warning disable CS0168
    #pragma warning disable 0168
    // 둘다 가능
    {% endhighlight %}

### 재정의된 메서드의 선택 정확도 향상
- 기존에는 nullable 타입을 받는 메서드가 여러 타입으로 오버로드가 됐을때, null을 파라미터로 받는 경우 컴파일 에러가 발생했다.
- 그러나 6.0부턴 무조건 int? 인자를 받는 메서드로 실행된다.
- null을 리턴하는 Task 메서드를 Task.Run메서드에 넣는 경우도 Run(Func<Task> function)을 선택해서 실행하도록 하게 되었다.
    {% highlight c# %}
    public static Task Run(Func<Task> function);
    public static Task Run(Action function);
    {% endhighlight %}