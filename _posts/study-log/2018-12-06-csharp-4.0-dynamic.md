---
title:  "c# 기본서 - c# 4.0: dynamic"
date:   2018-12-07 10:42:00
tags: [c#, c#4.0, dynamic, reflection]
categories: study-log
---

### 4.0 주요변화
- 이전까지는 닷넷 1.0~3.5용으로 빌드되는 모든 어셈블리가 GAC(Global Assembly Cache)에 추가되는 경우 단일하게 `%windir%\assembly`였지만
- 4.0부터는`%windir%\Microsoft.NET\assembly`로 변경되었다.
- 같은동작을 하는 어셈블리를 .NET 2.0, .NET 4.0으로 각각 빌드해서 제공해야한다.


### 선택적 매개변스와 명명된 인자
- 파라미터 값이 없을때 초기값을 주고싶다면 다음과 같이 기재하면 된다.
    {% highlight c# %}
    public void Output(string name, int age = 0)
    {% endhighlight %}
    - 이때 ref, out 예약어는 함께 사용할 수 없고
    - 선택 매개변수가 시작되면 필수 매개변수를 사용할 수 없으며
    - 선택 매개변수가 시작되어도 params 유형의 매개변수를 정의할 수 있다.
- 주의할 점은 선택적 매개변수에 전달되는 인자 역시 차례대로 대응되며, 중간에 생략될 수 없다는 점이다.
    - 이는 다음과같이 명명을 통해 해결할 수 있다.
    {% highlight c# %}
    Output(age: 26, name: "박도연")
    {% endhighlight %}


### dynamic 예약어
- 4.0부터 python이나 ruby같은 동적언어와도 연동이 쉽도록 dynamic 예약어를 추가했다.
- c#은 정적언어이기 때문에 **컴파일 시점**에 초깃값과 대응되는 타입으로 치환하지만,
- dynamic 예약어는 그렇게 하지않고 **실행시점**에 치환을 한다.
- Object 타입으로 선언해도 동작하지만, dynamic을 쓰는게 가독성측면에서 낫다. 결국 간편표기의 한 방법이다.


### dynamic을 통한 리플렉션 개선
- *12/5일자 글에 리플렉션에 대한 설명이 있다
- 기존에 리플렉션을 사용하려면 메소드 정보를 호출한 다음 invoke 메소드를 통해 인자를 넘겨줘야하는데,
- dynamic 예약어를 사용하면 아래정도의 코드로 간단하게 해결가능하다
    {% highlight c# %}
    dynamic txt = "test func"
    bool result = txt.Contains("test");
    {% endhighlight %}


### 덕타이핑
- 공통되는 상속없이 이름만 동일한 메서드나 속성을 호출하는 경우 맥락에 따라 적절한 객체를 실행시켜준다.
    {% highlight c# %}
    int DuckTypingCall(dynamic target, dynamic item) {
        return target.IndexOf(item);
    }
    
    string txt = "test func"
    List<int> list = new List<int>();

    DuckTypingCall(txt, "text"); // 0
    DuckTypingCall(list, 3); // 2
    {% endhighlight %}
