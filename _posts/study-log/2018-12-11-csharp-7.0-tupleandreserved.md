---
title:  "c# 기본서 - c# 7.0: 예약어와 ValueTask/ValueTuple"
date:   2018-12-07 12:06:00
tags: [c#, c#7.0, tuple, out, ref, lambda, ValueTask, is, when, default, switch/case]
categories: study-log
---

### 7.0 주요변화
- c# 7.0출시시 닷넷 버전은 4.6.2였다, 현재 7.0에 대응되는 프레임워크는 4.7이다.
- `ValueTuple` 타입이 추가되었다.
  - 그러나 4.6.2 닷넷 프레임워크에는 없으므로 nuget패키지를 통해 `System.ValueTuple`을 직접 설치해야한다
-  `System.Threading.Tasks.ValueTask`가 추가되었는데, 마찬가지로 지원하지 않으므로 `System.Threading.Tasks.Extensions.dll`을 참조추가해야한다.


### out 매개변수 쉽게 사용하기
- 기본에는 out매개변수 사용을 위해서는 따로 선언을 해줬어야했지만, 이제는 타입을 함께 입력해주면 선언이 필요없다.
    {% highlight c# %}
    int.TryParse("5", out int result);
    int.TryParse("6", out int result); //컴파일시 6.0코드로 변환 하기때문에 같은 변수명으로 입력하면 컴파일 에러발생!
    {% endhighlight %}


### 반환값/로컬변수에 ref 사용
- 메서드를 통해 배열의 특정 요소만 반환하는 등의 사용이 가능하다
- 가독성 문제가 있지만 메서드의 값 설정과 할당이 동시에 가능해진다.
    {% highlight c# %}
    class MyMetrix
    {
        int[,] _matrix = new int[100, 100]
        public ref int Put(int c, int r)
        {
            return ref _matrix[c, r];
        }
    }
    {
        MyMetrix m = new MyMetrix();
        int result = Matrix.Put(1, 1) = 1;
        Console.WriteLine(result) //1
    }
    {% endhighlight %}
- 주의할 점은 메서드 내부에서 선언한 지역변수와 같은 경우 실행 후 호출측으로 넘어갈 때 스택이 해제되어 return ref으로 반환된 인스턴스가 남아있을거라는 보장이 없다.
- 또한, ref 예약어를 지정한 지역변수는 다시 다른 변수를 가리키도록 변경할 수 없다.

### ValueTuple 도입 이유: dynamic, System.Tuple의 한계
- 튜플은 기본적으로 여러개의 요소를 반환해야하지만 일일히 클래스를 만들기가 번거로울 때 사용된다.
  - 물론 아래와같이 c# 3.0의 익명 타입과 4.0의  dynamic 예약어를 이용할수도 있지만, 런타임시 리스크가 있다.
    {% highlight c# %}
    {
        dynamic result = ParseInteger("20"); //dynamic
        Console.WriteLine(result.Parsed);
        Console.WriteLine(result.Number);
        //정적 형식검사가 안돼 나중이 필드 이름이 바뀌어도 컴파일시 문제를 알아낼 수 없는 문제가 있다.
    }
    dynamic ParseInteger(string text)
    {
        int number = 0;
        try
        {
            number = Int32.Parse(text);
            return new { Number = number, Parsed = true }; //익명 타입
        }
        catch
        {
            return new { Number = number, Parsed = false };
        }
    }
    {% endhighlight %}
- System.Tuple을 이용해 문제를 해결할수도 있지만
  - 변수 이름이 무조건 Item1, 2.. 와같이 정해지며
  - 파이썬과같은 언어랑 비교했을 때 상대적으로 복잡하다.
    {% highlight c# %}
    {
        Tuple<bool, int> result = pg.ParseInteger("40");
    }
    Tuple<bool, int> ParseInteger(string text)
    {
        int number = 0;
        bool result = false;
        try
        {
            number = Int32.Parse(text);
            result = true
        }
        catch { }
        return Tuple.create(result, number);
    }
    {% endhighlight %}

### ValueTuple의 도입
1. Return 타입에 직접 이름을 지정하거나, 호출하는 측에서 강제로 이름을 지정할수도 있다.
2. item1, item2 .. 과같은 방식의 호출도 가능하다.
3. out 매개변수 처리에서 지원했던 생략기호도 반환값 분해 구문에 사용할 수 있다.
- 모든 튜플은 제너릭 타입으로 변경해서 처리한다
  - 닷넷 4에서 제공하는 System.Tuple은 class 타입으로 정의된 반면
  - 4.7의 ValueTuple은 struct로 정의되어있다는 차이가 있다.
- Deconstruct라는 특별한 이름을 지정한 메서드를 정의해서 out 파라미터를 받아 직접 튜플을 구현할수도 있다.
    {% highlight c# %}
    {
        var result = pg.ParseInteger("40");
        Console.WriteLine(result.Parsed);
        Console.WriteLine(result.Number);

        (bool success, int n) caller = pg.ParseInteger("40");
        Console.WriteLine(caller.success);
        Console.WriteLine(caller.n);

        (bool ret, int num) = pg.ParseInteger("40");
        Console.WriteLine(ret);
        Console.WriteLine(num);

        (var _, var _) = pg.ParseInteger("40"); //2개값 모두 생략
        (var _, var n) = pg.ParseInteger("40"); //마지막 값만 n으로 받음
    }
    (bool Parsed, int Number) ParseInteger(string text) //Return 타입에 이름 지정
    {
        //생략
        return (result, number)
    }
    {% endhighlight %}

### lambda 메서드 정의 확대 
- 아래의 메서드에대한 lambda 정의가 7.0부터 가능해졌다.
  - 생성자/소멸자
  - 이벤트 클래스의 add/remove
  - 속성/인덱서의 set

### 지역함수
- 메서드 내에서만 활용할 수 있는 지역함수 문법이 추가되었다.
- 익명함수 표기도 가능하며, 단일식이면 람다로도 표현가능하다.
- 표기는 자유롭지만, c# 컴파일러는 internal 접근자를 가진 메서드로 정의해 타입 내에 자동으로 추가한다.

### ValueTask<T>: async메서드 반환타입으로 사용자 정의 Task타입을 반환할 수 있게됨 
- async 예약어가 붙는 메서드는 반환타입이 void, Task, Task<T> 중에 하나여야한다
- 문제는 메서드 내에서 await호출이 되지 않아 비동기 처리가 필요 없을때도 Task 객체가 생성되어 성능상 불이익이 발생한다.
- 여기서 반환 타입을 ValueTask<T>형식으로 바꿔주면 비동기 처리를 하지 않을 경우에는 Task 객체 생성이 일어나지 않는다.
    {% highlight c# %}
    static string _filecontents = string.Empty;
    private static async Task<(string, int)> FileReadAsync(string filePath)
    {
        if (string.IsNullOrEmpty(_filecontents) == false)
                return (_filecontents, Thread.CurrentThread.ManagedThreadId);
        
        _filecontents = await ReadAllTextAsync(filePath);
        return (_filecontents, Thread.CurrentThread.ManagedThreadId);
    }
    
    {% endhighlight %}

### 자유로운 throw 사용
- throw는 식(expression)이 아닌 문(statement)에 해당한다.
- 즉 '항'의 개념이 아니므로 삼항연산자에 사용되려면 메서드를 별개로 만들어 우회해서 사용해야 했었다.
- 7.0부터는 직접 사용이 가능하며,
  - 그렇다해서 모든 구문이 사용한것은 아니고 사용이 안되는 맥락에서는 컴파일 에러를 발생시킨다.

### 리터럴의 가독성 상승을 위한 표현방식 개선
- 7.0부터 숫자 내의 임의의 위치에 밑줄을 추가할 수 있다.
  - 10,000,000 와 같은 표현을 위해 int number = 10_000_000 형식으로 표기 가능하다.
- 숫자뿐만이 아니라 16진수 표현도 가능하다.

### 패턴 매칭(상수, null, 참조타입, 값타입, var 등...): is 연산
- is는 as와 기본적으로 동일한 기능을 수행한다.
- 차이점은 as는 변수에 캐스팅 결과가 담기지만,
- is는 구문자체로는 True/False를 반환하고, 비교 타입 뒤에 변수명을 입력하면 해당 변수에 캐스팅된 값이 할당된다는 차이점이 있다.
    {% highlight c# %}
    object obj = new List<string>();
    if(obj is List<string> list)
        list.ForEach(e => Console.WriteLine(e));

    object[] object = new object[] { 100, null, DateTime.Now, new ArrayList() };
    foreach(object item in objList)
    {
        if (item is 100) {
            //item 사용
        } else if (item is null) { 
            //item 사용
        } else if (item is DateTime dt) {
            //dt 사용
        }
    }
    {% endhighlight %}
- var도 가능하지만 사실상 의미가 없다.
  - 단 var 타입뒤에 변수명 반드시 써줘야하며, 이것도 의미가 없으면 언더바(_)로 입력하면된다.


### 패턴 매칭: switch/case 연산
- case 예약어 다음에 "[타입] [변수명]"을 넣으면 is 예약어처럼 사용 가능하다
- case 구문 뒤에 when 예약어를 추가하면 조건을 한번 더 검사할 수 있다. 예외필터의 when과 사용법이 동일하다.
- 튜플타입과 같은 복잡한 인자를 받을 때 var와 when 구문을 사용하면 훨씬 간결하게 사용할 수 있다.
    {% highlight c# %}
    Action<(int, int)> detectZeroOr = (arg) =>
    {
        switch (arg)
        {
            case var r when r.Equals(0, 0):
            case var r1 when r1.Item == 0:
            case var r2 when r2.Item == 0:
                return;
        }
        Console.WriteLine("both nonzero")
    }
    {% endhighlight %}

### defalut 리터럴 형식 추가
- 2.0에 추가된 default는 (T)를 인자로 받았다.
  - 문자 그대로 T를 인자로 받으면 컴파일시 기본값을 추측하는데,
- 7.0부터 어차피 타입추론이 이뤄지므로 지정이 필요없다고 판단하고 리터럴로 사용하게 됐다.

